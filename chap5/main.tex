\chapter{Conclusions}
\setupuuchapterbib

In this dissertation, we have demonstrated the primary aspects of the dissertation statement:

\thesisstmt

In \cref{cha2}, we extended the SMACK verifier to support programs written in the Rust programming language.
%
In that work, there were multiple additions and fixes that needed to be applied to SMACK in order to verify new Rust programs.
%
The Rust compiler used LLVM constructs that were not used by programs generated by the C-compiler \texttt{clang}.
%
These include the following:
%
\begin{itemize}
\item Handling new LLVM intrinsic operations related to detecting integer overflow, which was solved by adding an integer overflow checker to SMACK.
\item Support for handling 1-bit integer values.
\item More robust handling for the loading of structure members, which may be part of a structure that is cast to a primitive.
\end{itemize}
%
We added the following verification related features for Rust in SMACK:
\begin{itemize}
\item A \textit{panic} detection mode that can be used to find calls to Rust's panic functions which represent unrecoverable errors.
\item Added verification primitives such as \texttt{verifier\_assert}, \texttt{verifier\_assume} and the ability to create non-deterministic values.
%
A verifier friendly allocator and a dynamically sized array \texttt{Vec} class.
\end{itemize}
%
We made a prototype for cross-language verification to show its viability.
%
And with the modifications to SMACK, we were able to verify the IFC example shown in~\cref{lst:rustifc} of~\cref{sec:ifc}.

This work showed the viability of extending SMACK to become a general LLVM verifier through adding support for Rust.

In \Cref{cha3}, we push the ideas from~\Cref{cha2} further.
%
In this work, we develop a procedure for adding support for new languages to SMACK.
%
We begin by creating basic benchmarks in a language to make sure basic features of the language work in SMACK.
%
For example, some programming languages implement integer arithmetic through the use of compiler intrinsics, whose LLVM representation is not easily attainable.
%
Loops in Swift are implemented with iterators whose details are also part of the Swift runtime.
%
These issues are dealt with similarly to how unmodeled where models for these operations are added as either a library for the language, or are modeled at the LLVM level.

In this work, we extended SMACK to support multiple input programs.
%
This automates the process of verifying program properties in cross-language verification tasks.
%
The example functions shown in \cref{fig:factrsc} of \cref{sec:gensmack} were verified to be equivalent for small values of \texttt{n}.

This showed that the approach used to add support for Rust to SMACK can be generalized to support for new programming languages.

In \cref{chap4}, we tested SMACK as extended in prior work to test its applicability to verifying properties of real-world code.
%
Prior to this, SMACK's multi-language extensions had only been applied to either small programs, or programs written in only one programming language.
%
In this work, we applied SMACK to the task of verifying the equivalence of a source-level translation of the C language \texttt{musl} math library into a Rust-language math library.
%
This Rust library is popular with tens of millions of downloads and hundreds of dependents~\cite{libm-crate}.

There were anticipated difficulties with regard to scalability of checking equivalence of this work due to the difficulty of the bit-vector and floating-point SMT theories.
%
We developed an extension to SMACK aimed at helping guide the SMT solver toward identifying the equivalence.
%
In this work, SMACK was able to verify the equivalence of larger programs, in this case up to about 100 lines of code between shared between the C-language and Rust-language versions of the same program.
%
This showed that SMACK together with earlier extensions is able to check correctness properties of important, practical programs.

Results from this work have had industry impact.
%
The SMACK verifier has been used by Amazon Web Services (AWS) for example for many years.
%
The Rust extensions to SMACK have also recently been used by AWS.

Prior to the work in \Cref{chap4}, a prototype tool was built for checking equivalence between programs written in Rust and Dafny~\cite{dafny}.
%
Dafny is a programming language that is meant to verify programs meet specifications.
%
Dafny uses Boogie IVL to verify the properties of its programs.
%
The prototype tool combines SMACK's translations of Rust programs to Boogie with Dafny's Boogie representation, then checks that the Rust program and the Dafny program are equivalent.
%
This work differs slightly in that it is meant to transitively prove that the Rust program meets the specification in the Dafny program.
%
This tool has been extended and continues to be used within AWS.



% \section{Future Work}
% SMACK does not use any information from the Rust compiler.
% %
% Due to Rust's type system, there is a lot of information that would be helpful for verification.
% %
% For example, Rust variables cannot be aliased arbitrarily in safe code.
% %
% Information about how variables are used can be useful for SMACK to create finer memory maps which reduces solver burden.
% %
% By contrast, in C, using an \texttt{int} and a \texttt{float} interchangeably through a union means SMACK must combine the memory regions for both types.
% %
% The way to do this in Rust is to explicitly convert to and from their bit-wise and float representations.

% A new tool which uses SMACK whic can automatically identify possible equivalent variables and expressions between the C and Rust programs.
% %
% This could be extended from the approach used in the D\textsc{iff}K\textsc{emp}~\cite{diffkemp}.
% %
% However, SMACK would only be used for possible semantic equality to guide the solver, rather than trying to prove equivalence directly.
% %
% This would reduce user effort in checking equivalence.

\bibliographystyle{plain}
\bibliography{refs}