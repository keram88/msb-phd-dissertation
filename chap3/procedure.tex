\section{Procedure for Adding a Language}
\label{sec:procedure}

In this section, we introduce our prescribed procedure for adding support for
a new programming language into an LLVM-based software verifier.
%
The procedure is based on our study of adding languages to SMACK, but the
lessons we learned generalize to other verifiers that have similar
architecture.
%
By showing how the procedure of adding a new language to SMACK is relatively
straightforward, we also motivate the adoption of a SMACK-like verifier
architecture.
%
Note that while our procedure is focused on LLVM, we expect that a similar
process could be adopted for any IR-based verifier.
%
We structure our procedure into three tasks: interoperating with language
models, compiling into compiler intermediate representation (IR), and adding
models for missing language features.



\subsection{Interoperating with Language Models}
\label{sec:smack-code}

A software verifier has to encode the desired semantics of an input programming
language in order to perform verification.
%
In the case of an LLVM-based software verifier, that typically amounts to
providing a memory model in addition to models for LLVM IR statements generated
by the chosen compiler.
%
A memory model encodes dynamic memory allocation, pointer dereferencing, and
memory accesses.
%
Adding a new programming language necessitates for the verification to be able
to interoperate with the mentioned models.


The architecture of SMACK allows for a new programming language to easily
interoperate with SMACK models, as \cref{fig:vmcaixlang} shows.
%
First, SMACK's models for LLVM IR instructions are general and internal to
SMACK, and hence they can be shared across all languages that are compiled into
LLVM IR.
%
Second, SMACK's memory model~\cite{smack-mem-model} is encoded as a regular C
language header and its accompanying implementation.
%
This is achieved using the convenient \lstc{__SMACK_code} mechanism described
in~\cref{sec:smack-code} , which allows for the low-level model encoding to be
done at the level of C.
%
We must be able to link an input program with this header in order to
interoperate with the memory model.
%
According to our experience, most languages have interoperability with the C
language as a feature.
%
Hence, linking against the SMACK's memory model in a new programming language
is an easy task.
%
It is worth emphasizing that since the code in the new language is linking with
the C code of the memory model, every verification in a new language is already
a cross-language verification.


%To implement these verifier primitives, SMACK injects boogie code into the
%translation. It does this through the use of a special function called
%\lstc{__SMACK_code()}, which does not have a C implementation. Instead,
%whenever SMACK sees a call to \lstc{__SMACK_code()}, it hijacks the call,
%inserting the parameter (a string) into the boogie code. 
%
%
%For SMACK to verify a program in a meaningful way, the program must use
%verifier primitives like assert, assume, and nondet. SMACK implements this 
%functionality in smack.c, and exposes this in smack.h. 
%
%One limitation is that when SMACK looks for calls to \lstc{__SMACK_code()},
%it pattern-matches the function signature to the IR generated by clang's C code. 
%This means that in order to use these functions, a program must call the C functions
%defined in smack.c. In theory, \lstc{__SMACK_code()} could be re-implemented
%to pattern match the output of a different compiler, but as most languages have
%C interoperability as a feature, this is not necessary in our experience.
%
%Thus, a program to be verified must interop with SMACK's C modules, as defined
%in smack.h, to be verified properly. 


\subsection{Compiling and Linking into Compiler IR}

As opposed to verifiers that operate directly on program source, an IR-based
verifier needs for the input program to be first compiled into the chosen IR.
%
In the case of the LLVM compiler infrastructure, there are many popular
programming languages with front-ends that output LLVM IR.
%
Hence, producing LLVM IR for the programming language of choice is
typically straightforward.
%
Once the input program is compiled into IR, it gets linked with the SMACK
models, which are written in either C (common ones) or the target language
(language-specific ones) and automatically compiled by SMACK.
%
The resulting 
linked IR file is in turn handed over to the SMACK verifier for
processing (see \cref{fig:vmcaixlang}).
%
A verifier needs a program entry point, such as function \lstc{main} in C, to
know from where to start the verification process.
%
The LLVM IR specification does not prescribe a well-defined entry point, and
hence language developers are free to choose how to define the entry point for
a program in their language --- most languages define entry points other than
\lstc{main}.
%
Thus, we either implement a simple post-processing step to mark the program's
entry point, or manually specify it in SMACK's command line, which is in turn
passed to the SMACK verifier.


\subsection{Adding Models for Missing Language Features}
\label{sec:library-models}

When adding a new language, we typically observe three categories of models
that might be missing in a verifier: unsupported LLVM IR
instructions, runtime features, and standard libraries.

LLVM IR is an extensive format comprised of more than one hundred instructions
and intrinsics~\cite{llvm-lang-ref}, many of which are not commonly used.
%
Hence, when adding a new language, its compiler can potentially generate IR
instructions or intrinsics that a verifier has not encountered before, and hence are
potentially not supported.
%
This necessitates updating the verifier to account for the semantics of such
instructions.
%
Our experience shows that in the case of a mature LLVM-based verifier such as
SMACK, we rarely encountered a new compiler generating instructions/intrinsics
that it did not already support.


Most languages require the use of a standard library to achieve almost anything
of practical value.
%
SMACK provides extensive models for the C standard library, such as pthreads,
strings, and math.
%
However, every programming language comes with its own standard libraries that
it relies on, with different specifications.
%
A language may rely heavily on its standard libraries, even if it has
little or no runtime.
%
For example, unlike C, D, and Fortran, 
languages such as Rust and Swift implement arrays
as a compound type in the standard library.
%
Hence, models for the standard libraries of a new programming language have to
be written manually mostly from scratch.
%
This is the most tedious and time consuming aspect of adding support for a new
language.
%
To somewhat alleviate the burden of developing models, SMACK architecture
enables for a user to write models for standard library functions as header
files that are linked with input programs.
%
This is a convenient mechanism for writing such models since it requires no
updates to be made to the actual SMACK verifier source code.


Some languages are also heavily dependent on runtime functionality, such as
Objective-C, Swift, and Kotlin. 
%
For example, Objective-C relies heavily on its runtime for method dispatch,
memory management, and other basic features.
%
Code from the runtime is not included in the LLVM IR which is generated
by the compiler.
%
Therefore, runtime functions must be modeled before
any nontrivial verification.
%
Languages like C, Fortran, and D have very few runtime models, and as a 
result these are much easier languages to verify out-of-the-box.

