\section{Experience}
\label{sec:experience}

In this section, we describe our experience of applying the procedure
introduced in \cref{sec:procedure} to add support for new languages
into SMACK as well as perform cross-language verification.
%
First, we discuss why our approach and procedure allow us to trivially
support many language constructs of the added programming languages
(\cref{sec:supported-features}).
%
Second, we describe key challenges that we encountered in the process of
adding support for new languages and propose solutions for them
(\cref{sec:challenges-solutions}).
%
Third, we present our experience with leveraging the cross-language verification
capability to perform equivalence checking (\cref{sec:cross-language}).



\subsection{Trivially Supported Features}
\label{sec:supported-features}

SMACK is a mature C verifier that has been successfully applied on numerous
C programs, including large-scale real-world C projects such as OpenSSH, SQLite,
and Linux device drivers.
%
Hence, SMACK already fully supports an extensive subset of LLVM IR that gets
generated by the clang C compiler.
%
For example, the key language constructs of LLVM IR such as functions, control
flow, arithmetic, and derived types are completely modeled.
%
As a result, SMACK readily supports new languages of which compilers emit LLVM
IR code that is akin to what clang generates.
%
We find that these languages are typically also procedural C-like languages,
such as Fortran and D.


As it turns out, to our surprise, SMACK was often able to out-of-the-box
support even language features that are not found in C.
%
For example, without any modifications SMACK could handle the vectorized
addition of arrays in Fortran, which we show in \cref{fig:fortran-ex}.
%
After inspecting the IR code generated by the Fortran compiler, we observe that
the vectorized addition operation compiles into an element-wise array addition,
which is a common IR operation and hence was already supported by SMACK.

%Modifications, while trivial, are still required. For example, LLVM IR allows
%arbitrary characters to compose identifier names.
%
%However, Boogie identifier names are much more restricted which only allow
%alphanumeric characters plus a limited set of special characters.
%
%Both Objective-C and Kotlin make use of semicolons in their LLVM names and Kotlin
%even uses semicolons, angle brackets, and parenthesis.
%
%Simply translating these identifiers to identical Boogie
%identifiers as what is done in the C support causes syntax errors.
%
%However, A simple extension to SMACK's naming policies easily fixes this problem.

Having an extensive subset of LLVM IR supported also saved us from modeling a
lot of key program constructs in non-C-like languages such as Rust and Swift.
%
For example, even though function calls and control flow constructs are
different from those found in C (e.g., closures and match expressions), they
are compiled to the subset of LLVM IR that was already understood by SMACK.
%
Therefore, our approach enables us to evade cumbersome modeling of advanced
language features such as closures.
%
In this regard, our experience demonstrates the advantages of our IR-based
approach for multi-language verification.


%\subsection{Runtime Sizes}
%
%We define the \textit{runtime} of a programming langauge to be all functionality
%that is 1) necessary for a user to write real code, and 2) is not written by the
%user. For example, the C runtime includes methods such as \lstc{malloc},
%\lstc{free}, and string processing methods like \lstc{strlen}.
%
%In the context of LLVM, runtime functions and datatypes are often declared but
%not implemented in compiled IR, with the expectation that runtime code will be
%linked in before runtime. As a translator, SMACK does not have access to these
%implementations. Therefore, any runtime functionality must be modeled by SMACK.
%
%As a general rule, the time it takes to add robust support for a langauge to
%SMACK is directly proportional to the size of its runtime. For example, C
%has a very small runtime and is easily supported, and Objective-C has an
%extensive runtime and take quite a bit of work to support.
%
%As such, we divide all of our suitable LLVM compilers into two categories:
%those with a small runtime, those with an extensive runtime, and those
%whose compilers are not suitable for SMACK.
%
%\textbf{Small Runtime}
%\begin{itemize}
%    \item C (clang)
%    \item C++ (clang)
%    \item D (ldc)
%    \item Fortran (flang)
%\end{itemize}
%
%\textbf{Large Runtime}
%\begin{itemize}
%    \item Objective-C (clang)
%    \item Rust (rustc)
%    \item Swift (swiftc)
%    \item Kotlin (kotlinc)
%\end{itemize}
%
%\subsection{Languages with a Small Runtime}
%
%Each of these languages required small changes to SMACK and it's tooling
%to support, but there were no modifications that went beyond the level of
%a bugfix or small enhancement.
%Fortran is of particular note among these languages because it did not require
%any internal modifications to SMACK at all.
%
%An example of such a problem is escaping more characters in names. LLVM IR allows
%arbitrary characters to be in identifier names. However, boogie identifiers are
%much more restricted and only allow alphanumeric characters plus a limited set
%of special characters. For example, colons and semicolons are not allowed in
%boogie identifiers, but can be used in LLVM identifiers. Clang's C support does
%not use this functionality, but other langauges often do. Before this was fixed,
%SMACK would simply copy the boogie-invalid LLVM identifier, causing crashes.
%A simple extension to SMACK's internal naming class fixed this problem.
%
%Despite being similar to C, all of the languages with small runtimes
%have features that C itself does
%not support.
%Thus, there are many features that C does not have, which
%SMACK is able to support out of the box. This is the power of targeting LLVM.
%
%One example of a SMACK-supported non-C
%feature is class declarations with fields.
%In D, we can define a class such as:
%
%\begin{lstlisting}
%class Point
%{
%    int x;
%    int y;
%    this(int _x, int _y) {
%        x = _x;
%        y = _y;
%    }
%}
%\end{lstlisting}
%
%When this is compiled into LLVM, it becomes a struct type:
%
%\begin{lstlisting}
%%compound.Location = type { %compound.Location.__vtbl*, i8*, i32, i32 }
%\end{lstlisting}
%
%Methods are compiled into LLVM procedures, like any C function.
%
%Array in Fortran are compiled into pointers, so that once they are
%compiled, they look similar to compiled C arrays. Consider the following
%start of a subroutine declaration (free-form Fortran is used for readibility):
%
%\begin{lstlisting}
%subroutine process_vectors(A,B,S)
%  implicit none
%  integer, dimension(2) :: A, B, S
%\end{lstlisting}
%
%The above declaration is translated into the following
%llvm declaration:
%
%\begin{lstlisting}
%define internal void @process_vectors_(i64* %a, i64* %b, i64* %s) #0 !dbg !59 {
%\end{lstlisting}
%
%We can see that the parameters, A, B, and S, all of which are integer arrays of
%length 2 based on the declaration, compile into pointers to integers in LLVM IR.


\subsection{Adding New Languages: Challenges and Solutions}
\label{sec:challenges-solutions}

As expected, supporting even a small subset of a new language in a verifier
is often challenging.
%
For example, a major challenge is the need to model previously unsupported LLVM
IR constructs.
%
Our experience shows that the compilers of non-C-like languages, such as Rust
and Swift, indeed produce LLVM IR that was not supported by SMACK.
%
Moreover, another important challenge is that we have to model a language
runtime and its standard libraries to enable for practically usable
verification.
%
In the rest of this section, we describe in detail these challenges as well as
our efforts to solve them.


\subsubsection{Unsupported LLVM Constructs}

SMACK is a mature verifier that has been thoroughly tested on C programs,
including thousands of SVCOMP benchmarks as well as large real-world
applications such as OpenSSH.
%
Despite SMACK's maturity, we found that compilers for the emerging languages,
such as Rust and Swift, readily generate LLVM IR constructs we do not observe in
LLVM IR generated from C code by clang.
%
Hence, we had to extend SMACK with support for such constructs, and we
describe some of these next.


%
% handling of structures
%
Both the Rust and Swift compilers heavily rely on the use of LLVM structure
types, often emitting different instructions involving structures than what
clang would generate.
%
We solved this problem by modeling LLVM IR structure types using
uninterpreted functions that recursively constrain each
field.
%
For example, we represent value \lstllvm{\{v,1\}} of structure type \lstllvm{\{T,i1\}}
using an integer \lstboogie{s} with constraint
\lstboogie{f(s,0)==v && f(s,1)==1}, where \lstboogie{f} is an
uninterpreted function with the second argument being the index of a
structure field.
%
This encoding allows us to model two basic LLVM IR structure instructions
\lstllvm{extractvalue} and \lstllvm{insertvalue} that read and write
structure fields, respectively.
%
Loads and stores of structures into memory are recursively translated into a
sequence of instructions that generate load/store for each field of
primitive type, in conjunction with the two aforementioned instructions.

Another previously unsupported but frequently used LLVM IR construct is intrinsics.
%
% summarize integer overflow intrinsics
%
For example, both the Rust and Swift compilers default to using LLVM IR's
overflow arithmetic intrinsics, such as
\lstllvm{llvm.add.with.overflow.i32}.
%
The \lstrust{leading_zeros} methods of unsigned integer types in Rust are
compiled to \lstllvm{llvm.ctlz.*} intrinsics.
%
Such intrinsics can be easily modeled.
%
For example, we model these intrinsics in SMACK by first performing the
requested operation in the double-bit-width precision, to avoid potential
overflows.
%
Then, we inspect the result to detect if it overflowed, in which case we either
report an overflow error or we block the overflowing path.


In addition to supporting more LLVM IR instructions, we also extended SMACK
to support instruction sequences that are not regularly generated by clang.
%
For example, the Rust compiler performs a \emph{packing} optimization where
structures with a size less than 8 bytes are packed into 8 byte integers
(e.g., a load of a structure of type \lstllvm{\{i32,i32\}} gets encoded as a
load of \lstllvm{i64}).
%
This breaks the completeness of SMACK's memory model~\cite{smack-mem-model},
which is not precise enough to capture such low-level operations, thereby
leading to false alarms.
%
We added an analysis pass to SMACK that detects load/store instruction
patterns with pointer operands of integer element type that refer to
structures.
%
We translate such patterns to load from or store into structure fields
(following the encoding described earlier), thereby avoiding packing.

Although we had to model these additional constructs, our approach still
demonstrates the advantages discussed in \cref{sec:supported-features}:
%
modeling one LLVM IR construct benefits the support of multiple languages,
and this process becomes progressively easier as adding a new language
benefits from previous modeling efforts.


\subsubsection{Languages with Large Runtimes}
\label{sec:large-runtimes}

Getting a verifier to translate LLVM IR generated from a language with a
large runtime is not any more difficult than for languages with smaller
runtimes.
%
However, performing a nontrivial verification task for such a language is
much harder, because even rudimentary language features are sometimes under
the hood implemented using complex runtime constructs and standard
libraries.
%
Moreover, the source code implementing such features is not
readily accessible to the verifier as IR code linked with the program
source.
%
We found this to be the most challenging problem when adding a new language
to a verifier.
%
Note that this problem persists even if the verification is done directly on
program source (as opposed to IR) since the source code of the underlying
runtime is typically not available, written in a different programming
language, or too large to be efficiently handled by a verifier.


As an example of such a language feature, consider the for-in loop over an
iterable structure.
%
All of the languages with substantial runtime we considered provide such a
feature.
%
In fact, in Swift, Kotlin, and Rust, the C-style for loop is not even
supported, and range structures are used to emulate the same behavior.
%
Consider this simple example in Swift:
\lstswift{for i in 0..<10 \{x += 5\}}.
%
The compiler translates the code \lstswift{0..<10} using a
\lstswift{Range<Int>} structure/class, whose member methods are then called
in the compiled loop code.
%
The code of such member methods is not readily available to the verifier,
but is a part of the runtime.
%
On the other hand, both Kotlin and Rust compile such loops into basic LLVM
IR instructions that do not contain method calls into runtime, despite the
high-level concept of a range being similar to Swift. 
%
Many features of large-runtime languages are implemented like this, and they
vary wildly between languages. 
%
Examples of other basic language features the heavily depend on runtime
include method dispatch (Swift, Objective-C), arrays (Swift, Objective-C,
Rust, Kotlin), and object instantiation (Kotlin).
%
As a more extreme example, even basic arithmetic in Kotlin is abstracted
into invoking methods belonging to its runtime, instead of generating the
appropriate LLVM IR instructions directly.
%
We relied on two solutions to overcome such problems, with different
trade-offs, as we describe next.


We compile and link an existing implementation of the runtime/standard
library with the input program.
%
For example, to support basic integer operations in Kotlin, we used the
existing implementation of these operations from the Kotlin runtime and
linked it with the input program. 
%
The main advantage of this approach is that it requires no manual effort.
%
It also avoids the user potentially introducing errors while modeling the
runtime.
%
The main drawback is that the standard libraries and runtime are generally
very large, and this may cause verification to blow up even on small input
programs. 
%
For example, the implementation of the array structure in Swift is thousands
of lines of code.
%
Such code is also heavily optimized, and often relies on low-level bit
vector operations and compiler builtins, which further complicate its
verification.

% \begin{table}[p]
% \caption[Sizes of models we developed for each language]{Sizes of models we developed for each language.
%   Column \textbf{Model LOC} gives the size of each model
%   in terms of lines of code.
% }
% \label{tab:model-sizes}
% \vspace{1em}
% \centering
% \setlength{\tabcolsep}{8pt}
% \ra{1.75}
% \begin{tabular}{@{}lr@{}}
% 	\toprule
% 	\textbf{Language} & \textbf{Model LOC} \\
% 	\midrule
% 	C &  2566 \\
% 	C++ &  13 \\
% 	Fortran &  38 \\
% 	D &  0 \\
% 	Rust & 480 \\
% 	Objective-C & 0 \\
% 	Swift &  2 \\
% 	Kotlin & 17 \\
% 	\bottomrule
% \end{tabular}
% %\vspace{-3mm}
% \end{table}


We model the standard libraries and runtime by writing stubs for the
relevant methods.
%
\cref{tab:model-sizes} gives the sizes of the models we developed for each
language we support.
%
SMACK already came with extensive models for the C standard library and a part
of the Rust standard library, which is why these two models are by far the
largest.
%
The main advantage of this approach is that the manually written models make
the verification much more tractable, and hence most verifiers, no matter
whether they are IR-based or not, require it to achieve scalable verification.
%
The main drawback is that writing them is a tedious manual effort that
requires detailed understanding of the language specifications.
%
Hence, we did not do that for other languages.
%
In principle, the standard libraries and runtime of Kotlin, Objective-C, and
Swift could each be modeled in a similar way to Rust.
%
Note that this solution is contradictory to the general principle of our
approach since it requires per-language modeling.


\subsection{Cross-Language Verification}
\label{sec:cross-language}
%
Although our experience with cross-language verification is limited to
equivalence checking of programs written in different languages, it captures an
important pattern in cross-language development: a program written in one
language uses external libraries written in another language.
%
Furthermore, equivalence checking is a useful application of cross-language
verification, giving confidence to developers that a new, native implementation
of a library retains the behaviors of the previous non-native implementation.
%
This is especially true when large rewriting efforts are under way, such as
replacing legacy libraries implemented using Fortran with C/C++ implementations
in the context of high-performance computing, or libraries implemented using C
with their Rust counterparts.


We find that once the languages involved in the cross-language verification
process are well-supported and there are available mechanisms for these
languages to interoperate, cross-language verification is feasible, highly
automated, and comes almost for free.
%
This is expected since our approach casts the problem of cross-language
verification into the problem of verifying a single language, namely LLVM IR.
%
Therefore, the main impediments we encountered while verifying cross-language
programs were related to SMACK's incomplete support for LLVM IR, similarly to
our efforts to add support for new languages.
%
For example, while performing the case study, the only issue we encountered was
that SMACK did not model the LLVM count-leading-zeros intrinsics.
%
We quickly added support for this instruction and were able to complete the
verification process smoothly.
