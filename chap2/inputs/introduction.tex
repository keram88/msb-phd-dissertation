Rust~\cite{rust-link,rust14} is a new programming language that aims
at enabling safe systems programming by means of an elaborate type
system.
%
It avoids memory safety issues prevalent in programs written in other
low-level programming languages such as C/C++ without adding performance
overhead often imposed by runtime systems or garbage
collectors.
%
Because of these merits, Rust has received a lot of attention from both
academia and industry, and it has been used to write production code shortly
after the release of version 1.0 in 2015.
%
Many industrial-strength safety-critical applications are being built in Rust,
such as web browsers, cloud storage, and embedded software~\cite{rust-friends,Levy2017}.


Although memory safety is enforced through type checking of
Rust programs at compile time, functional correctness (e.g., no violations of
user-specified assertions) is not guaranteed.
%
Automated software verifiers (e.g.,~\cite{smack-cav,ClarkeKL04,esbmc,calysto,cascade,Beyer2011,framac,gravy,tacas2007-clqr,joogie,klee,llbmc,satabs,symbc,tass,Albarghouthi2012,vcc,seahorn,civl})
based on
satisfiability modulo theories (SMT) solvers~\cite{smtlib} are a popular choice
for assuring the absence of assertion violations.
%
However, building a verifier, or extending an existing one, for a new language
is often tedious and time-consuming (e.g., implement a front-end, understand
and encode the language semantics).
%
For example, CRUST~\cite{crust}, a prototype verifier targeting memory safety
bugs in unsafe Rust code~\cite{unsafe-rust}, transforms Rust into C, which
makes it highly dependent on the still-evolving language details.
%
CRUST requires constant updates to keep up with the changes to Rust, which is a
large undertaking, and CRUST is no longer maintained.
%
To the best of our knowledge, currently there are no full-fledged, up-to-date
SMT-based verifiers for Rust.


In this chapter, we describe how we enable the verification of Rust
programs in the SMACK verifier~\cite{smack-cav,smack-web} with considerably less
effort than previous work~\cite{crust}.
%
Form more information about SMACK, please see \cref{sec:smackground}.
%
An advantage of SMACK is that it is input-language agnostic as it works by
verifying an intermediate representation (IR), specifically LLVM
IR~\cite{lattner2004llvm}.
%
Since the official Rust compiler, \rustc{}, can produce LLVM IR code corresponding
to Rust programs, a large front-end development effort was not needed as a rich
set of LLVM IR features is already supported by SMACK.
%any programming language with a compiler capable of emitting LLVM IR code can
%leverage SMACK's existing modeling of LLVM IR programs. Since Rust's official
%compiler, rustc, emits LLVM IR, it is natural to extend SMACK to support
%verification for programs written in this language.
%Even though C is currently the primary language that SMACK verifies, its input language agnosticism as a result of operating on an intermediate code representation (LLVM IR [4]) ostensibly allows the verification of any programming language with a compiler capable of pro- ducing LLVM IR, which is the case for Rust
%
%Nevertheless, extending SMACK to accept Rust programs is not push-button.
%
Rust is an emerging programming language that implements advanced language
features such as traits, smart pointers, and closures.
%
Hence, Rust's compiler emits LLVM IR code patterns that are often significantly
different from what is generated by the C compiler Clang~\cite{clang}, which is
the language that SMACK has primarily been used for.
%
Nevertheless, we managed to extend SMACK to support the verification of a
modern programming language such as Rust at a relatively small cost, and our
evaluation shows that it can already handle a variety of key language features.



%the focus of this paper is to present the missing
%components for extending SMACK to support Rust and interesting, novel
%augmentations done to SMACK during the extension.\shaobo{Talk about
%experiment results.}

% Should be a list 
%We will discuss the changes made to SMACK:
%\begin{itemize}
%  \item Changes made to enable SMACK to verify LLVM IR generated by
%the Rust compler.
%  \item Describe libraries that were developed to enable verification
%of non-trivial codes.
%  \item The development of a library to enable verification constructs
%to be expressed in idiomatic Rust.
%\end{itemize} Finally, we describe experiments which demonstrate real
%Rust programs which have been verified with the extended SMACK.

